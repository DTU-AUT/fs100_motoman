#include <ros/ros.h>
#include <std_msgs/String.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netdb.h> 

#include <pthread.h>
#include <signal.h>

#include "motoman_direct_message.h"

int runState = 0;
int thread_temp = 0;

void ctrlCHandler(int s){

    int signal =0;

    signal = s;

    printf("Caught signal %d \n\n\n\n\n\n\n",signal);

    runState++;



}
void *keyboard_thread(void *arg){
    while(runState==0){
        if(thread_temp==0){
            printf("thread state1");
            thread_temp=1;
        }
    }
    thread_temp=0;
    while(runState==1){
        if(thread_temp==0){
            printf("thread state2");
            thread_temp=1;
        }
    }
    thread_temp=0;
    while(runState==2){
        if(thread_temp==0){
            printf("thread state3");
            thread_temp=1;
        }
    }   
    printf("stop thread!");
}

void error(const char *msg)
{
    perror(msg);
    exit(0);
}

void byte_swap(char* data,int length){ //destructive
    char buffer[length];
    memcpy(buffer,data,length);
    for(int i=0;i<length/4;i++){ //number of int/float
        for(int k = 0;k<4;k++){ //for every byte in int/float
            data[(i*4)+k] = buffer[(i*4)+(3-k)];
            
        }
    }
}

void seri_simple(SimpleMsg *msg, char *data,int size){
    memcpy(data,msg,size);
}

void deseri_simple(char* data, SimpleMsg *msg){
    memcpy(msg,data,sizeof(*msg));
}

void deserialize_joint_feedback(char *data,SimpleMsg *msg){
    int *q = (int*)data;
    //prefix
    msg->prefix.length =  *q; q++;
    //header
    msg->header.msgType = (SmMsgType) *q; q++;
    msg->header.commType =(SmCommType) *q; q++;
    msg->header.replyType = (SmReplyType) *q; q++;
    //body
    msg->body.jointFeedback.groupNo = *q; q++;
    msg->body.jointFeedback.validFields = *q; q++;
    //change from integer to float
    msg->body.jointFeedback.time = *(float*)q; q++;
    for(int i=0;i<10;i++){
        msg->body.jointFeedback.pos[i] = *(float*)q; q++;
    }
    for(int i=0;i<10;i++){
        msg->body.jointFeedback.vel[i] = *(float*)q; q++;
    }
    for(int i=0;i<10;i++){
        msg->body.jointFeedback.acc[i] =  *(float*)q; q++;
    }
    
}

void deserialize_motion_reply(char *data,SimpleMsg *msg){
    int *q = (int*)data;
    //prefix
    msg->prefix.length =  *q; q++;
    //header
    msg->header.msgType = (SmMsgType) *q; q++;
    msg->header.commType =(SmCommType) *q; q++;
    msg->header.replyType = (SmReplyType) *q; q++;
    //body
    msg->body.motionReply.groupNo = *q; q++;
    msg->body.motionReply.sequence = *q; q++;
    msg->body.motionReply.command = *q; q++;
    msg->body.motionReply.result = (SmResultType) *q; q++;
    msg->body.motionReply.subcode = *q; q++;
    for(int i=0;i<10;i++){
        msg->body.motionReply.data[i] = *(float*)q; q++;
    }    
}

void print_motion_reply(SimpleMsg *msg){
    printf("Prefix:\n");
    printf("  length: %d\n",msg->prefix.length);
    printf("header:\n");
    printf("  msgType: %d\n",msg->header.msgType);
    printf("  commType: %d\n",msg->header.commType);
    printf("  replyType: %d\n",msg->header.replyType);
    printf("body:\n");
    printf("  motionReply:\n");
    printf("    groupNo: %d\n",msg->body.motionReply.groupNo);
    printf("    sequence: %d\n",msg->body.motionReply.sequence);
    printf("    command: %d\n",msg->body.motionReply.command);
    printf("    result: %d\n",msg->body.motionReply.result);
    printf("    subcide: %d\n",msg->body.motionReply.subcode);
    printf("    data:\n");
    for(int i=0;i<10;i++){
        printf("      data[%d]: %f\n",i,msg->body.motionReply.data[i]);
    }
}
    
void print_traj_full(SimpleMsg *msg){
    printf("Prefix:\n");
    printf("  length: %d\n",msg->prefix.length);
    printf("header:\n");
    printf("  msgType: %d\n",msg->header.msgType);
    printf("  commType: %d\n",msg->header.commType);
    printf("  replyType: %d\n",msg->header.replyType);
    printf("body:\n");
    printf("  jointTrajData:\n");
    printf("    groupNo: %d\n",msg->body.jointTrajData.groupNo);
    printf("    validFields: %d\n",msg->body.jointTrajData.validFields);
    printf("    sequence: %d\n",msg->body.jointTrajData.sequence);
    printf("    time: %f\n",msg->body.jointTrajData.time);
    printf("    pos:\n");
    for(int i=0;i<10;i++){
        printf("      joint[%d]: %f\n",i+1,msg->body.jointTrajData.pos[i]);
    }
    printf("    vel:\n");
    for(int i=0;i<10;i++){
        printf("      joint[%d]: %f\n",i+1,msg->body.jointTrajData.vel[i]);
    }
    printf("    acc:\n");
    for(int i=0;i<10;i++){
        printf("      joint[%d]: %f\n",i+1,msg->body.jointTrajData.acc[i]);
    }
}

void print_joint_feedback(SimpleMsg *msg){
    printf("Prefix:\n");
    printf("  length: %d\n",msg->prefix.length);
    printf("header:\n");
    printf("  msgType: %d\n",msg->header.msgType);
    printf("  commType: %d\n",msg->header.commType);
    printf("  replyType: %d\n",msg->header.replyType);
    printf("body:\n");
    printf("  jointFeedback:\n");
    printf("    groupNo: %d\n",msg->body.jointFeedback.groupNo);
    printf("    validFields: %d\n",msg->body.jointFeedback.validFields);
    printf("    time: %f\n",msg->body.jointFeedback.time);
    printf("    pos:\n");
    for(int i=0;i<10;i++){
        printf("      joint[%d]: %f\n",i+1,msg->body.jointFeedback.pos[i]);
    }/* //Not valid
    printf("    vel:\n");
    for(int i=0;i<10;i++){
        printf("      joint[%d]: %f\n",i+1,msg->body.jointFeedback.vel[i]);
    }
    printf("    acc:\n");
    for(int i=0;i<10;i++){
        printf("      joint[%d]: %f\n",i+1,msg->body.jointFeedback.acc[i]);
    }*/
}

int build_traj_full(SimpleMsg *tm,float pos[6],float time,int seq){
    // set prefix: length of message excluding the prefix
	tm->prefix.length = sizeof(SmHeader) + sizeof(SmBodyJointTrajPtFull);
	
	// set header information
	tm->header.msgType = ROS_MSG_JOINT_TRAJ_PT_FULL;
	tm->header.commType = ROS_COMM_SERVICE_RESQUEST;
	tm->header.replyType = ROS_REPLY_INVALID;
	
	// set body
	tm->body.jointTrajData.groupNo = 0;
	tm->body.jointTrajData.validFields = 7;
	tm->body.jointTrajData.sequence = seq;
	tm->body.jointTrajData.time = time;
	for(int i=0;i<6;i++){
    	tm->body.jointTrajData.pos[i] = pos[i];
    	tm->body.jointTrajData.vel[i] = (float)0.0;
    	tm->body.jointTrajData.acc[i] = (float)0.0;
	}
	for(int i=6;i<10;i++){
    	tm->body.jointTrajData.pos[i] = (float)0.0;
    	tm->body.jointTrajData.vel[i] = (float)0.0;
    	tm->body.jointTrajData.acc[i] = (float)0.0;
	}

}
int build_traj_vel(SimpleMsg *tm,float pos[6],float vel[6],float time,int seq){
    // set prefix: length of message excluding the prefix
	tm->prefix.length = sizeof(SmHeader) + sizeof(SmBodyJointTrajPtFull);
	
	// set header information
	tm->header.msgType = ROS_MSG_JOINT_TRAJ_PT_FULL;
	tm->header.commType = ROS_COMM_SERVICE_RESQUEST;
	tm->header.replyType = ROS_REPLY_INVALID;
	
	// set body
	tm->body.jointTrajData.groupNo = 0;
	tm->body.jointTrajData.validFields = 7;
	tm->body.jointTrajData.sequence = seq;
	tm->body.jointTrajData.time = time;
	for(int i=0;i<6;i++){
    	tm->body.jointTrajData.pos[i] = pos[i];
    	tm->body.jointTrajData.vel[i] = vel[i];
    	tm->body.jointTrajData.acc[i] = (float)0.0;
	}
	for(int i=6;i<10;i++){
    	tm->body.jointTrajData.pos[i] = (float)0.0;
    	tm->body.jointTrajData.vel[i] = (float)0.0;
    	tm->body.jointTrajData.acc[i] = (float)0.0;
	}

}

int get_length(char* data){
    int length = *(int*) data;
    return length;
}

void motion_ready(SimpleMsg *msg){
    //prefix
    msg->prefix.length = sizeof(SmHeader) + sizeof(SmBodyMotoMotionCtrl);
    //header
    msg->header.msgType = ROS_MSG_MOTO_MOTION_CTRL;
    msg->header.commType = ROS_COMM_SERVICE_RESQUEST;
    msg->header.replyType = ROS_REPLY_INVALID;
    //body
    msg->body.motionCtrl.groupNo = 0;
    msg->body.motionCtrl.sequence = 0;
    msg->body.motionCtrl.command = ROS_CMD_CHECK_MOTION_READY;
    for(int i=0;i<10;i++){
        msg->body.motionCtrl.data[i] = (float) 0.0;
    }
}

void trajectory_start(SimpleMsg *msg){
    //prefix
    msg->prefix.length = sizeof(SmHeader) + sizeof(SmBodyMotoMotionCtrl);
    //header
    msg->header.msgType = ROS_MSG_MOTO_MOTION_CTRL;
    msg->header.commType = ROS_COMM_SERVICE_RESQUEST;
    msg->header.replyType = ROS_REPLY_INVALID;
    //body
    msg->body.motionCtrl.groupNo = 0;
    msg->body.motionCtrl.sequence = 0;
    msg->body.motionCtrl.command = ROS_CMD_START_TRAJ_MODE;
    for(int i=0;i<10;i++){
        msg->body.motionCtrl.data[i] = (float) 0.0;
    }
}


int main(int argc, char **argv){
    ros::init(argc, argv, "motoman_direct_test");
    ros::NodeHandle node_handle; 
    ros::AsyncSpinner spinner(1);
    spinner.start();
    
    //// create socket to robot_state and connect ////
    int sockfd, portno, n, i = 1;
    struct sockaddr_in serv_addr;
    struct hostent *server;
    portno = 50241;
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    int opt = setsockopt( sockfd, IPPROTO_TCP, TCP_NODELAY, (void *)&i, sizeof(i));
    setsockopt( sockfd, IPPROTO_TCP, TCP_QUICKACK, (void *)&i, sizeof(i));
    if (sockfd < 0) 
        error("ERROR opening socket");
    server = gethostbyname("192.168.1.10");
    if (server == NULL) {
        fprintf(stderr,"ERROR, no such host\n");
        exit(0);
    }
    bzero((char *) &serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server->h_addr, 
         (char *)&serv_addr.sin_addr.s_addr,
         server->h_length);
    serv_addr.sin_port = htons(portno);
    if (connect(sockfd,(struct sockaddr *) &serv_addr,sizeof(serv_addr)) < 0) 
        error("ERROR connecting");
        
    //// create socket to motion control and connect ////
    int sockfd_ctrl, portno_ctrl;
    struct sockaddr_in serv_addr_ctrl;
    struct hostent *server_ctrl;
    portno_ctrl = 50240;
    sockfd_ctrl = socket(AF_INET, SOCK_STREAM, 0);
    i = 1;
    setsockopt( sockfd_ctrl, IPPROTO_TCP, TCP_NODELAY, (void *)&i, sizeof(i));
    setsockopt( sockfd_ctrl, IPPROTO_TCP, TCP_QUICKACK, (void *)&i, sizeof(i));
    if (sockfd_ctrl < 0) 
        error("ERROR opening socket");
    server_ctrl = gethostbyname("192.168.1.10");
    if (server_ctrl == NULL) {
        fprintf(stderr,"ERROR, no such host\n");
        exit(0);
    }
    bzero((char *) &serv_addr_ctrl, sizeof(serv_addr_ctrl));
    serv_addr_ctrl.sin_family = AF_INET;
    bcopy((char *)server_ctrl->h_addr, 
         (char *)&serv_addr_ctrl.sin_addr.s_addr,
         server_ctrl->h_length);
    serv_addr_ctrl.sin_port = htons(portno_ctrl);
    if (connect(sockfd_ctrl,(struct sockaddr *) &serv_addr_ctrl,sizeof(serv_addr_ctrl)) < 0) 
        error("ERROR connecting");

    //////create keyboard thread /////
    // Lets catch Ctrl+C
    struct sigaction sigIntHandler;
    sigIntHandler.sa_handler = ctrlCHandler;
    sigemptyset(&sigIntHandler.sa_mask);
    sigIntHandler.sa_flags = 0;

    sigaction(SIGINT, &sigIntHandler, NULL);
    
    
    
    pthread_t getkbID;
    
    //if(pthread_create(&getkbID,NULL,&keyboard_thread,NULL)){
    //printf("Error in keyboard Thread creation\n");
    //return -1;
    //}
    
    ////create message////
    SimpleMsg traj_point,joint_data,motion_cmd,motion_rpl;
    //////////////////////
    //Get start position
    char raw_data[255];
    char traj_buffer[152];
    char motion_buffer[68];
    char motion_reply_buffer[76];
    n = recv(sockfd,raw_data,sizeof(raw_data),0);
    if (n < 0) 
         error("ERROR reading from socket");
    i = 1;
    setsockopt( sockfd, IPPROTO_TCP, TCP_QUICKACK, (void *)&i, sizeof(i));
    byte_swap(raw_data,sizeof(raw_data));
    //Checking data type (length 40=status; length 144=joint feedback)
    if (get_length(raw_data)==44){
        printf("got status\n");
    }
    else if(get_length(raw_data)==144){
        printf("got joint feedback\n");
        deserialize_joint_feedback(raw_data,&joint_data);
    }
    print_joint_feedback(&joint_data);
    
    ////send motion ready////
    motion_ready(&motion_cmd);
    seri_simple(&motion_cmd,motion_buffer,sizeof(motion_buffer));
    byte_swap(motion_buffer,sizeof(motion_buffer));
    n = write(sockfd_ctrl,motion_buffer,sizeof(motion_buffer));
    if (n < 0) 
         error("ERROR writing to socket");

        n = recv(sockfd_ctrl,motion_reply_buffer,sizeof(motion_reply_buffer),0);
        byte_swap(motion_reply_buffer,sizeof(motion_reply_buffer));
        deserialize_motion_reply(motion_reply_buffer,&motion_rpl);
    printf("\n\nmotion ready sent, reply:\n");
    ros::Duration(0.01).sleep();
    print_motion_reply(&motion_rpl);
    
    ////send trajectory mode start////
    trajectory_start(&motion_cmd);
    seri_simple(&motion_cmd,motion_buffer,sizeof(motion_buffer));
    byte_swap(motion_buffer,sizeof(motion_buffer));
    n = write(sockfd_ctrl,motion_buffer,sizeof(motion_buffer));
    if (n < 0) 
         error("ERROR writing to socket");
    printf("\n\ntrajectory start sent, reply:\n");
        n = recv(sockfd_ctrl,motion_reply_buffer,sizeof(motion_reply_buffer),0);
        byte_swap(motion_reply_buffer,sizeof(motion_reply_buffer));
        deserialize_motion_reply(motion_reply_buffer,&motion_rpl);
    print_motion_reply(&motion_rpl);
    ros::Duration(0.05).sleep();
    
    ////create first trajectory point and send////
    float pos[6] = {joint_data.body.jointFeedback.pos[0],joint_data.body.jointFeedback.pos[1],joint_data.body.jointFeedback.pos[2],joint_data.body.jointFeedback.pos[3],joint_data.body.jointFeedback.pos[4],joint_data.body.jointFeedback.pos[5]};

    
    build_traj_full(&traj_point,pos,(float) 0.0,0);
    
    seri_simple(&traj_point,traj_buffer,sizeof(traj_buffer));
    byte_swap(traj_buffer,sizeof(traj_buffer));
    n = write(sockfd_ctrl,traj_buffer,sizeof(traj_buffer));
    if (n < 0) 
         error("ERROR writing to socket");
        n = recv(sockfd_ctrl,motion_reply_buffer,sizeof(motion_reply_buffer),0);
        byte_swap(motion_reply_buffer,sizeof(motion_reply_buffer));
        deserialize_motion_reply(motion_reply_buffer,&motion_rpl);
    
    printf("\n\nfirst point sent, reply:\n");
    print_motion_reply(&motion_rpl);
    
    //ros::Duration(0.05).sleep();
    //create second trajectory point and send
    for(int i=0;i<6;i++) pos[i] = (float) 0.0;
    build_traj_full(&traj_point,pos,(float) 0.5,1);
    
    seri_simple(&traj_point,traj_buffer,sizeof(traj_buffer));
    byte_swap(traj_buffer,sizeof(traj_buffer));
    n = write(sockfd_ctrl,traj_buffer,sizeof(traj_buffer));
    if (n < 0) 
         error("ERROR writing to socket");
    //ros::Duration(0.05).sleep();
        n = recv(sockfd_ctrl,motion_reply_buffer,sizeof(motion_reply_buffer),0);
        byte_swap(motion_reply_buffer,sizeof(motion_reply_buffer));
        deserialize_motion_reply(motion_reply_buffer,&motion_rpl);
    printf("\n\nsecond point sent, reply:\n");
    print_motion_reply(&motion_rpl);
    
    
    ///stream points and vel!///
    float delta_t=0.002; //magic number?
    float vel[6];
    int seq = 1;
    float time = 0.5;
    int retry = 1;
    ros::Time t_now, t_last;
    t_now = ros::Time::now();
    t_last = ros::Time::now();
    for(int i=0;i<6;i++) vel[i]=(float)0.0;
    while(runState<2){
        t_now = ros::Time::now();
        
        printf("loop took: %f\n",t_now.toSec()-t_last.toSec());
        t_last = ros::Time::now();
        if(runState==0){ //one way
            for(int i=0;i<6;i++){
                vel[i] = 0.1;
                pos[i] = pos[i]+vel[i]*delta_t;
            }
            retry = 1;
            time += delta_t;
            seq ++;
            build_traj_vel(&traj_point,pos,vel,time,seq);
            seri_simple(&traj_point,traj_buffer,sizeof(traj_buffer));
            byte_swap(traj_buffer,sizeof(traj_buffer));
            while(retry){
                if(runState!=0){
                    retry = 0;
                    break;
                }
                write(sockfd_ctrl,traj_buffer,sizeof(traj_buffer));
                recv(sockfd_ctrl,motion_reply_buffer,sizeof(motion_reply_buffer),0);
                byte_swap(motion_reply_buffer,sizeof(motion_reply_buffer));
                deserialize_motion_reply(motion_reply_buffer,&motion_rpl);
                if(motion_rpl.body.motionReply.result == 1) printf("result: BUSY\n");
                else if (motion_rpl.body.motionReply.result == 0){
                    printf("results: SUCCESS\n");
                    retry = 0;
                }
                //ros::Duration(0.001).sleep();
            }
        }
        
        if(runState==1){ //other way
            for(int i=0;i<6;i++){
                vel[i] = 0.1;
                pos[i] = pos[i]-vel[i]*delta_t;
            }
            retry = 1;
            time += delta_t;
            seq ++;
            build_traj_vel(&traj_point,pos,vel,time,seq);
            seri_simple(&traj_point,traj_buffer,sizeof(traj_buffer));
            byte_swap(traj_buffer,sizeof(traj_buffer));
            while(retry){
                if(runState!=1){
                    retry = 0;
                    break;
                }
                write(sockfd_ctrl,traj_buffer,sizeof(traj_buffer));
                recv(sockfd_ctrl,motion_reply_buffer,sizeof(motion_reply_buffer),0);
                byte_swap(motion_reply_buffer,sizeof(motion_reply_buffer));
                deserialize_motion_reply(motion_reply_buffer,&motion_rpl);
                if(motion_rpl.body.motionReply.result == 1) printf("result: BUSY\n");
                else if (motion_rpl.body.motionReply.result == 0){
                    printf("results: SUCCESS\n");
                    retry = 0;
                }
                //ros::Duration(0.001).sleep();
            }
        }
            
    }
    //pthread_join(getkbID,NULL);
    ros::shutdown(); 
    return 0;
}

